# -*- coding: utf-8 -*-
"""Analise de inventario Florestal_2022.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/14GcfAC6Y17ax_P-r2QHu4IHOugEvAXSW

#1.0. **Introdução**

Este é um estudo de análise de dados de um inventário florestail de um reflorestamento de teca (Tectona grandis). Para este estudo utilizou-se Python e suas bibliotecas: Pandas, Seaborn, Matplotlib, Numpy e scikit-learn.

O ojetivo principal é utilizar a linguagem python e suas bibliotecas como ferramentas para avaliações em reflorestamentos e posteriormente criar um modelo de aprendizado de maquina capaz de prever a produção florestal baseado nas curvas de regressão lienar e logaritmica dos dados reais de medições (5 anos).

#2.0. Importando bibliotecas necessárias
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
import numpy as np
import datetime as dt

# %matplotlib inline

"""#2.1. Importando planilha de medição"""

inventario = pd.read_excel('/content/INVENTÁRIO FLORESTAL_2023.xlsx')
inventario

"""Procurou-se observar as informações que compõe a base de dados (inventário) e assim constatar quais são os tipos de dados a serem estudados."""

inventario.info()

"""Baseados nas informações, procurou-se entender as medições consecutivas por datas de medições.
No ano de 2018 o reflorestamento teve 25 medições (em 25 talhões), sendo que algumas destes foram realizadas em datas distintas.

Posteriormente no ano de 2019 e 2020, foram medidos 25 talhões. No ano de 2021 foram medidos apenas 24 talhões e não 25 como nos anos anteiores.
"""

#Contabilizando as mensurações anuais dos talhões
qtd_idade = inventario['Data_medição'].value_counts()
qtd_idade

"""Conforme resultado apresentado acima, despertou interesse de entender qual talhão foi mensurado unicamente na data de 10-08-2018, uma vez que as mensurações nos demais talhões se deram no mês posterior (mês 09). Percebe-se também que no ano de 2021 teve 24 mensurações, o que configura que um talhão deixou de ser medido por alguma razão.

**Supoe-se que:** A equipe não entrou no talhão para mensurar por algum motivo ou até mesmo por razões técnicas da empresa em não levar adiante as mensurações do mesmo.
"""

tb_idade = inventario[['Data_medição','ID_talhao','Area_talhao_ha','Idade_anos','DAP_medio', 'Area_Basal', 'VOL_tot_m3ha','Altura_tot_m']]
inventario2018_1 = tb_idade[tb_idade["Data_medição"] == "2018-08-10"]
inventario2018_1

"""Embora que no ano de 2028 houve 25 mensurações, ou seja, 25 talhões mensurados naquele ano, constatou-se que o **Talhão 14B** foi o único mensurado separadamente em data distinta dos demais (10-08-2018).

Contudo, precisamos tentar verificar qual foi o talhão que não foi mensurado no ano de 2021.
"""

num_med_talhao = inventario.ID_talhao.value_counts()
num_med_talhao.sort_values()

"""O **talhão 14B** não foi mensurado no ano de 2021 por algum motivo.

#3.0 Análise de inventário atual (2022)

Primeiramente vamos buscar separar as mensurações do ano de 2022 e realizar uma análise.
"""

tb_idade = inventario[['Data_medição','ID_talhao','Area_talhao_ha','Idade_anos','DAP_medio','Area_Basal','VOL_tot_m3ha','Altura_tot_m']]
inventario2022 = tb_idade[tb_idade["Data_medição"] == "2022-09-30"]
inventario2022

"""Verificando se existe algum dado corrompido ou ausência de informações."""

inventario2022.info()

"""Considerando o inventário realizado em 2022, realizou-se uma análise de correlação entre os Diâmetros x Volumes Totais m³ por hectare e Alturas Totais. Constatou-se que são fortemente correlacionadas na seguinte ordem:
1° - Altura Total e Diametro Médios com **0.9204**
2° - Altura Total e Volume Total com **0.8211**
3° - Diametros Médios e Volume Total com **0.7844**
"""

invent2021_corr = inventario2022[['DAP_medio','VOL_tot_m3ha','Altura_tot_m']]
invent2021_corr.corr()

"""Procurou-se organizar o inventário mais recente por ordem dos 5 maiores talhões em volume em metros cubicos por hectare. Percebe-se que o tamanho da área não é uma influencia direta nessa proporção de volume, pois o 3° nesta ordem (Talhão -  030) possui a maior área que as demais e seu volume é expressivamente menor que o 1° da lista (Talhão - 29C, este de área de 10.13 hectares)."""

talhao_vol_max = inventario2022.sort_values(by='VOL_tot_m3ha',ascending=False)
talhao_vol_max [:5]

"""Realizou-se a média do inventário florestal 2022"""

media2022 = inventario2022.mean()
media2022

"""resultado do volume total m³/ha"""

inventario2022['VOL_tot_m3ha'].sum()

"""Como o talhão 29C foi o que mais destacou, procurou-se entender seu histórico de mensurações (2018 até 2021) conforme apresenta o resultado abaixo:"""

talhao29C_mens_anual = inventario[inventario["ID_talhao"] == "29C"]
talhao29C_mens_anual

"""Gráfico de crescimento volumetrico anual do Talhão 29C (Volume Total m³/ha VS Idade)"""

sns.lineplot(data=talhao29C_mens_anual, x="Idade_anos", y="VOL_tot_m3ha")

"""#4.0. Explorando outras informações em nosso inventário

Vamos realizar alguns filtros importantes de verificação em nosso dataframe para investigar possíveis erros de digitação que possam induzir a interpretações erradas e equivocadas. Erros como posicionamento incorreto de virgulas entre as casas decimais e até mesmo ausência delas.

Qual foi o diâmetro máximo no inventário de 2022?
"""

dapmax2022 = inventario2022.DAP_medio.max()
dapmax2022

"""Em qual talhão encontra-se o diâmetro máximo?"""

inventario2022[(inventario2022['DAP_medio'] == dapmax2022)]

"""Qual foi o diâmetro minimo encontrado no inventário 2022?"""

menor_dap = inventario2022.DAP_medio.min()
menor_dap

"""Em qual talhão encontra-se o diâmetro minimo?"""

inventario2022[(inventario2022['DAP_medio'] == menor_dap)]

"""Qual foi o volume máximo encontrado no inventário 2022?"""

volmax2022 = inventario2022.VOL_tot_m3ha.max()
volmax2022

"""Em qual talhão encontra-se o volume máximo?"""

inventario2022[(inventario2022['VOL_tot_m3ha'] == volmax2022)]

"""Qual é o menor volume (m³/ha)?"""

menor_vol_ha = inventario2022.VOL_tot_m3ha.min()
menor_vol_ha

"""Em qual talhão temos o menor volume (m³/ha)?"""

inventario2022[(inventario2022['VOL_tot_m3ha'] == menor_vol_ha)]

"""#5.0. Utilizando Machine Learning (Previsão de crescimento) - Aprendizado Supervisionado

#5.1. Previsão com Regressão linear

Considerando que o modelo de regressão linear é uma técnica de aprendizado supervisionado que busca estabelecer uma relação linear entre uma variável dependente (nesse caso, as médias das colunas DAP_medio, Altura_tot_m e Area_Basal) e uma ou mais variáveis independentes no nosso caso: ano de medição.

Durante o treinamento do modelo, vamos utilizar os dados históricos das médias das colunas dos anos 2018 a 2022 para encontrar uma linha que melhor se ajuste aos pontos dos dados. Essa linha será a representação da relação linear que o modelo encontrará entre o ano e as médias das colunas.

Em seguida, vamos usar esse modelo treinado para fazer previsões para o ano de 2023. O modelo utilizará a equação da linha ajustada para estimar as médias das colunas correspondentes a esse ano.
"""

from sklearn.linear_model import LinearRegression

# Agrupando os dados por ano de medição e calculando as médias
inventario['Year'] = inventario['Data_medição'].dt.year
media_por_ano = inventario.groupby('Year').agg({
    'DAP_medio': 'mean',
    'Altura_tot_m': 'mean',
    'Area_Basal': 'mean'
}).reset_index()

# Agrupando os dados por ano de medição e calculando as médias
inventario['Year'] = inventario['Data_medição'].dt.year
media_por_ano = inventario.groupby('Year').agg({
    'DAP_medio': 'mean',
    'Altura_tot_m': 'mean',
    'Area_Basal': 'mean'
}).reset_index()

# Configurações do gráfico
plt.figure(figsize=(10, 6))
plt.grid(True)
plt.title('Médias por ano de medição')
plt.xlabel('Ano de medição')
plt.ylabel('Média')

# Plotando as linhas do gráfico para cada coluna
plt.plot(media_por_ano['Year'], media_por_ano['DAP_medio'], label='DAP médio', marker='o')
plt.plot(media_por_ano['Year'], media_por_ano['Altura_tot_m'], label='Altura total (m)', marker='o')
plt.plot(media_por_ano['Year'], media_por_ano['Area_Basal'], label='Área basal', marker='o')

# Adicionando os valores médios em cada ponto
for i in range(len(media_por_ano)):
    plt.text(media_por_ano['Year'][i], media_por_ano['DAP_medio'][i], f"{media_por_ano['DAP_medio'][i]:.2f}",
             ha='center', va='bottom')
    plt.text(media_por_ano['Year'][i], media_por_ano['Altura_tot_m'][i], f"{media_por_ano['Altura_tot_m'][i]:.2f}",
             ha='center', va='bottom')
    plt.text(media_por_ano['Year'][i], media_por_ano['Area_Basal'][i], f"{media_por_ano['Area_Basal'][i]:.2f}",
             ha='center', va='bottom')

# Adicionando legendas e mostrando o gráfico
plt.legend()
plt.xticks(media_por_ano['Year'])
plt.show()

"""Percebe-se que em 2021 tivemos uma queda na área basal - 10,97 para 10,41 m²/ha, provavelmente algum indicio de morte de umas árvores, um desbaste ou até mesmo a ausência da medição do talhão 14B naquele ano influenciou na queda deste valor. Contudo, isso não influenciará em nossa previsão e assim, com base nesses dados recentes, vamos realizar as previsões para o ano de 2023 e plotar novamente no gráfico para melhor visualização.

Nessa linha de código abaixo, estamos adicionando uma nova linha no DataFrame media_por_ano, representando o ano de 2023. A estrutura da linha é [ano, média_dap_medio, média_altura_tot_m, média_area_basal]. **Onde:**

**media_por_ano:** É o DataFrame que contém os dados de média das colunas DAP_medio, Altura_tot_m e Area_Basal para cada ano de medição.

**.loc[5]**: O .loc[] é um método do DataFrame que permite selecionar ou adicionar linhas pelo rótulo do índice. Nesse caso, estamos usando o índice numérico 5, que representa a linha onde queremos adicionar os dados do ano 2023.

**[2023, 0, 0, 0]**: Essa é a lista que representa os valores a serem adicionados na nova linha. Os valores são [ano, média_dap_medio, média_altura_tot_m, média_area_basal].

**2023:** É o valor para o ano, que representa o ano de 2023.
**0:** É o valor para a média de DAP_medio. Neste ponto, como ainda não temos a média para 2023, colocamos 0 temporariamente. Após calcularmos a média para 2023, atualizaremos esse valor.
**0:** É o valor para a média de Altura_tot_m. Também colocamos 0 temporariamente.
**0:** É o valor para a média de Area_Basal. Também colocamos 0 temporariamente.

Portanto, essa linha estará apenas preparando o DataFrame media_por_ano para incluir os dados referentes ao ano de 2023. Os valores de média para DAP_medio, Altura_tot_m e Area_Basal são colocados como 0 temporariamente e serão atualizados posteriormente, após fazer as previsões para o ano de 2023 utilizando o modelo de regressão logarítmica treinado com os dados dos anos anteriores.
"""

# Adicionando o ano para o qual queremos fazer a previsão (2023)


media_por_ano.loc[5] = [2023, 0, 0, 0]

# Obtendo as médias das colunas dos anos anteriores (2018 a 2022)
dados_treinamento = media_por_ano.iloc[:5]

# Separando as variáveis independentes (ano) e a variável dependente (média das colunas)
X_treinamento = dados_treinamento[['Year']]
y_dap = dados_treinamento['DAP_medio']
y_altura = dados_treinamento['Altura_tot_m']
y_area = dados_treinamento['Area_Basal']

# Criando os modelos de regressão linear
modelo_dap = LinearRegression()
modelo_altura = LinearRegression()
modelo_area = LinearRegression()

# Treinando os modelos
modelo_dap.fit(X_treinamento, y_dap)
modelo_altura.fit(X_treinamento, y_altura)
modelo_area.fit(X_treinamento, y_area)

# Fazendo a previsão para o sexto ano (2023)
dap_previsto_2023 = modelo_dap.predict(media_por_ano.iloc[5][['Year']].values.reshape(1, -1))
altura_prevista_2023 = modelo_altura.predict(media_por_ano.iloc[5][['Year']].values.reshape(1, -1))
area_prevista_2023 = modelo_area.predict(media_por_ano.iloc[5][['Year']].values.reshape(1, -1))

# Criando uma cópia do DataFrame para incluir as previsões
media_por_ano_com_previsao = media_por_ano.copy()

# Incluindo os valores previstos no DataFrame
media_por_ano_com_previsao.at[5, 'DAP_medio'] = dap_previsto_2023[0]
media_por_ano_com_previsao.at[5, 'Altura_tot_m'] = altura_prevista_2023[0]
media_por_ano_com_previsao.at[5, 'Area_Basal'] = area_prevista_2023[0]

# Configurações do gráfico
plt.figure(figsize=(10, 6))
plt.grid(True)
plt.title('Médias por ano de medição')
plt.xlabel('Ano de medição')
plt.ylabel('Média')

# Plotando as linhas do gráfico para cada coluna
plt.plot(media_por_ano_com_previsao['Year'], media_por_ano_com_previsao['DAP_medio'], label='DAP médio', marker='o')
plt.plot(media_por_ano_com_previsao['Year'], media_por_ano_com_previsao['Altura_tot_m'], label='Altura total (m)', marker='o')
plt.plot(media_por_ano_com_previsao['Year'], media_por_ano_com_previsao['Area_Basal'], label='Área basal', marker='o')

# Adicionando os valores médios em cada ponto
for i in range(len(media_por_ano_com_previsao)):
    plt.text(media_por_ano_com_previsao['Year'][i], media_por_ano_com_previsao['DAP_medio'][i], f"{media_por_ano_com_previsao['DAP_medio'][i]:.2f}",
             ha='center', va='bottom')
    plt.text(media_por_ano_com_previsao['Year'][i], media_por_ano_com_previsao['Altura_tot_m'][i], f"{media_por_ano_com_previsao['Altura_tot_m'][i]:.2f}",
             ha='center', va='bottom')
    plt.text(media_por_ano_com_previsao['Year'][i], media_por_ano_com_previsao['Area_Basal'][i], f"{media_por_ano_com_previsao['Area_Basal'][i]:.2f}",
             ha='center', va='bottom')


# Adicionando legendas e mostrando o gráfico
plt.legend()
plt.xticks(media_por_ano_com_previsao['Year'])
plt.show()

"""#5.2. Previsão com Regressão logaritmica"""

from sklearn.linear_model import LinearRegression
from sklearn.metrics import r2_score

# Adicionando o ano para o qual queremos fazer a previsão (2023)
media_por_ano.loc[5] = [2023, 0, 0, 0]

# Obtendo as médias das colunas dos anos anteriores (2018 a 2022)
dados_treinamento = media_por_ano.iloc[:5]

# Separando as variáveis independentes (ano) e a variável dependente (média das colunas)
X_treinamento = dados_treinamento[['Year']]
y_dap = dados_treinamento['DAP_medio']
y_altura = dados_treinamento['Altura_tot_m']
y_area = dados_treinamento['Area_Basal']

# Transformando a variável dependente usando a função logarítmica
y_dap_log = np.log(y_dap)
y_altura_log = np.log(y_altura)
y_area_log = np.log(y_area)

# Criando os modelos de regressão linear
modelo_dap = LinearRegression()
modelo_altura = LinearRegression()
modelo_area = LinearRegression()

# Treinando os modelos
modelo_dap.fit(X_treinamento, y_dap_log)
modelo_altura.fit(X_treinamento, y_altura_log)
modelo_area.fit(X_treinamento, y_area_log)

# Fazendo a previsão para o sexto ano (2023)
dap_previsto_2023_log = modelo_dap.predict(media_por_ano.iloc[5][['Year']].values.reshape(1, -1))
altura_prevista_2023_log = modelo_altura.predict(media_por_ano.iloc[5][['Year']].values.reshape(1, -1))
area_prevista_2023_log = modelo_area.predict(media_por_ano.iloc[5][['Year']].values.reshape(1, -1))

# Transformando as previsões de volta para a escala original usando a função exponencial
dap_previsto_2023 = np.exp(dap_previsto_2023_log)
altura_prevista_2023 = np.exp(altura_prevista_2023_log)
area_prevista_2023 = np.exp(area_prevista_2023_log)

# Calculando o R² para as previsões
r2_dap = r2_score(y_dap, np.exp(modelo_dap.predict(X_treinamento)))
r2_altura = r2_score(y_altura, np.exp(modelo_altura.predict(X_treinamento)))
r2_area = r2_score(y_area, np.exp(modelo_area.predict(X_treinamento)))

print(f"R² para DAP médio: {r2_dap:.2f}")
print(f"R² para Altura total: {r2_altura:.2f}")
print(f"R² para Área basal: {r2_area:.2f}")

# Configurações do gráfico
plt.figure(figsize=(10, 6))
plt.grid(True)
plt.title('Médias por ano de medição')
plt.xlabel('Ano de medição')
plt.ylabel('Média')

# Plotando as linhas do gráfico para cada coluna
plt.plot(media_por_ano_com_previsao['Year'], media_por_ano_com_previsao['DAP_medio'], label='DAP médio', marker='o')
plt.plot(media_por_ano_com_previsao['Year'], media_por_ano_com_previsao['Altura_tot_m'], label='Altura total (m)', marker='o')
plt.plot(media_por_ano_com_previsao['Year'], media_por_ano_com_previsao['Area_Basal'], label='Área basal', marker='o')

# Adicionando os valores médios em cada ponto
for i in range(len(media_por_ano_com_previsao)):
    plt.text(media_por_ano_com_previsao['Year'][i], media_por_ano_com_previsao['DAP_medio'][i], f"{media_por_ano_com_previsao['DAP_medio'][i]:.2f}",
             ha='center', va='bottom')
    plt.text(media_por_ano_com_previsao['Year'][i], media_por_ano_com_previsao['Altura_tot_m'][i], f"{media_por_ano_com_previsao['Altura_tot_m'][i]:.2f}",
             ha='center', va='bottom')
    plt.text(media_por_ano_com_previsao['Year'][i], media_por_ano_com_previsao['Area_Basal'][i], f"{media_por_ano_com_previsao['Area_Basal'][i]:.2f}",
             ha='center', va='bottom')



# Adicionando legendas e mostrando o gráfico
plt.legend()
plt.xticks(media_por_ano_com_previsao['Year'])
plt.show()

"""#6.0. Considerações Finais

Conclui-se que o Python é um excelente aliado a engenharia florestal para realizar nas mais diversas análises possíveis e a sua utilização na avaliação do presente inventário florestal foi extremamente importante e eficiente, principalmente pelas extensas bibliotecas empregadas em conjunto com as suas combinações.

Considerando que o presente trabalho foi de caráter de teste e conhecimento, o mesmo pode ser configurado para ser utilizado em outros trabalhos profissionais. Contudo, deve-se levar em consideração que neste, foram utilizados médias do reflorestamento geral, ou seja, medias dos 25 talhões existentes, e com isso, sugere-se empregar o algoritmo criado em nível de talhão (sob forma individual). Esta sugestão é reforçada na intenção de levar em consideração as especificidades de cada talhão, ou seja, cada um tem sua produtividade de forma particular em decorrência de seu sitio (este que possuem diferentes teores de solo, disponibilidade de macros e micros nutrientes, disponilidade de água, espaçamento e etc).

O mesmo trabalho poderia ser realizado na planilha em excel, porém seriam gastos muito tempo com formulações, seleção dos dados corretamente (n° de linhas) para criar gráficos e entre outros fatores que pode levar dias ou até semanas dependendo da dimensão da análise. Ainda considerando o fator "dimensão" ou até mesmo "tamanho", o excel não consegue trabalhar com dados em larga escala, pois é limitado e seus calculos podem demorar a finalizar e até mesmo apresentar erros (comuns) na sua conclusão, gerando perda dos dados e podendo até corrompe-los. Com o Python, uma vez criado o algoritmo, o mesmo poderá ser utilizado para outras planilhas de análises semelhantes, de forma automatizada, desde que tenham as mesmas nomenclaturas em suas colunas, independemente de ordem que estejam relacionadas e da quantidade de informações contidas em linhas.

Foi utilizado o scikit-learn que é uma biblioteca de aprendizado de máquina de código aberto para aprender os nossos dados levantados e assim criar um modelo linear e outro logaritmico de previsão de produção. Em ambos modelos, mostraram-se eficientes, embora que o logaritimico é o mais usual nessas avaliações em engenharia florestal. Pretende-se com essas previsões realizar comparações com dados reais a serem levantados no presente ano de 2023.
"""